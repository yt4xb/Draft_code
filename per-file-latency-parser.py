#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""@package ldm_parser
Copyright (C) 2015 University of Virginia. All rights reserved.

file      per-file-latency-parser.py
author    Shawn Chen <sc7cq@virginia.edu>
version   1.0
date      Nov. 1, 2015

modifider Yuanlong Tan <yt4xb@virginia.edu>
version	  2.0
date      Jan. 14, 2019
LICENSE

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or（at your option）
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details at http://www.gnu.org/copyleft/gpl.html

brief     parses log files generated by LDM7 receivers on a specified
          aggregate size basis.
usage     python per-file-latency-parser.py <logfile> <csvfile-to-write> <statfile-to-write>
"""


from __future__ import division
import re
import sys
import pytz
from dateutil.parser import parse
from datetime import datetime


def parseMLDM(line):
    """Parses the product size and elapsed time received by MLDM.

    Parses the product size and elapsed receiving time consumed
    for the product (which is received by MLDM) in the given line
    of log file.

    Args:
        line: A line of the raw log file.

    Returns:
        (-1, -1, -1): If no valid size or time is found.
        (prodindex, prodsize, rxtime): A tuple of product index, product size
                                       and receiving time.
    """
    match = re.search(r'.*mldm.*Received', line)
    if match:
        split_line = line.split()
        # the last column is product index
        prodindex = int(split_line[-1])
        # col 6 is size in bytes
        size = int(split_line[6])
        # col 0 is the arrival time, col 7 is the insertion time.
        arrival_time = parse(split_line[0]).astimezone(pytz.utc)
        arrival_time = arrival_time.replace(tzinfo=None)
        insert_time  = datetime.strptime(split_line[7], "%Y%m%d%H%M%S.%f")
        rxtime = (arrival_time - insert_time).total_seconds()
        return (prodindex, size, rxtime)
    else:
        return (-1, -1, -1)

def extractLog(filename):
    """Extracts the key information from the log file.

    Args:
        filename: Filename of the log file.

    Returns:
        (complete_set, complete_dict, vset): extracted groups.
    """
    complete_set  = set()
    complete_dict = {}
    with open(filename, 'r') as logfile:
        for i, line in enumerate(logfile):
            (mprodid, msize, mrxtime) = parseMLDM(line)
            if mprodid >= 0:
                complete_set |= {mprodid}
                if not complete_dict.has_key(mprodid):
                    complete_dict[mprodid] = (msize, mrxtime)
    logfile.close()
    return (complete_set, complete_dict)


def main(logfile, csvfile, statfile):
    """Reads the raw log file and parses it.

    Reads the raw ldmd log file, parses each line and computes throughput
    and VSR over an aggregate size.

    Args:
        metadata: Filename of the metadata.
        logfile: Filename of the log file.
        csvfile : Filename of the new file to contain output results.
    """
    x = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    s = open(statfile, 'w+')
    w = open(csvfile, 'w+')
    (rx_success_set, rx_success_dict) = extractLog(logfile)
    tmp_str = 'prodindex, latency (s)' + '\n'
    w.write(tmp_str)
    for i in rx_success_set:
        tmp_str = str(i) + ',' + str(rx_success_dict[i][1]) + '\n'
	if 0 < rx_success_dict[i][1] < 5:
		x[0] = x[0] + 1
	elif 5 < rx_success_dict[i][1] < 10:
		x[1] = x[1] + 1
	elif 10 < rx_success_dict[i][1] < 15:
		x[2] = x[2] + 1
	elif 15 < rx_success_dict[i][1] < 20:
		x[3] = x[3] + 1
	elif 20 < rx_success_dict[i][1] < 25:
		x[4] = x[4] + 1
	elif 25 < rx_success_dict[i][1] < 30:
		x[5] = x[5] + 1
	elif 30 < rx_success_dict[i][1] < 35:
		x[6] = x[6] + 1
	elif 35 < rx_success_dict[i][1] < 40:
		x[7] = x[7] + 1
	elif 40 < rx_success_dict[i][1] < 45:
		x[8] = x[8] + 1
	elif 45 < rx_success_dict[i][1] < 50:
		x[9] = x[9] + 1
	elif 50 < rx_success_dict[i][1] < 55:
		x[10] = x[10] + 1
	elif 55 < rx_success_dict[i][1] < 60:
		x[11] = x[11] + 1
	elif 60 < rx_success_dict[i][1] < 65:
		x[12] = x[12] + 1
	elif 65 < rx_success_dict[i][1] < 70:
		x[13] = x[13] + 1
	elif 70 < rx_success_dict[i][1] < 75:
		x[14] = x[14] + 1
	elif 75 < rx_success_dict[i][1] < 80:
		x[15] = x[15] + 1
	elif 80 < rx_success_dict[i][1] < 85:
		x[16] = x[16] + 1
	elif 85 < rx_success_dict[i][1] < 90:
		x[17] = x[17] + 1
	elif 90 < rx_success_dict[i][1] < 95:
		x[18] = x[18] + 1
	elif 95 < rx_success_dict[i][1] < 100:
		x[19] = x[19] + 1
	elif 100 < rx_success_dict[i][1] < 105:
		x[20] = x[20] + 1
	elif 105 < rx_success_dict[i][1] < 110:
		x[21] = x[21] + 1
	elif 110 < rx_success_dict[i][1] < 115:
		x[22] = x[22] + 1
	elif 115 < rx_success_dict[i][1] < 120:
		x[23] = x[23] + 1
	elif rx_success_dict[i][1] > 120:
		x[24] = x[24] + 1
	w.write(tmp_str)
    for i in range(len(x)):
	t = i - 1
	tmp_str = str(i) + ',' + str(x[t]) + '\n'
        s.write(tmp_str)
    w.close()


if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2], sys.argv[3])
